//go:build linux
// +build linux

// Package setup provides methods to install/unistall application as a service on the
// system
package setup

// ////////////////////////////////////////////////////////////////////////////////// //
//                                                                                    //
//                         Copyright (c) 2025 ESSENTIAL KAOS                          //
//      Apache License, Version 2.0 <https://www.apache.org/licenses/LICENSE-2.0>     //
//                                                                                    //
// ////////////////////////////////////////////////////////////////////////////////// //

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"strings"

	"github.com/essentialkaos/ek/v13/fsutil"
	"github.com/essentialkaos/ek/v13/hash"
	"github.com/essentialkaos/ek/v13/path"
	"github.com/essentialkaos/ek/v13/strutil"
	"github.com/essentialkaos/ek/v13/system"
)

// ////////////////////////////////////////////////////////////////////////////////// //

// App contains basic application configuration
type App struct {
	Name       string   // Application name
	Options    []string // List of options
	DocsURL    string   // Documentation URL
	User       string   // Service user
	Identifier string   // Syslog identifier
	WorkingDir string   // Working dir

	StopSignal   string // Stop signal
	ReloadSignal string // Reload signal

	WithLog            bool // Create directory for logs
	WithoutPrivateTemp bool // Disable private temp

	Configs []Config // Configuration files
}

// Config contains configuration file data
//
// Note that all configurations are stored in /etc
type Config struct {
	Name string      // File name
	Data []byte      // Data
	Mode os.FileMode // File mode
}

// ////////////////////////////////////////////////////////////////////////////////// //

// binaryInfo contains basic info about binary
type binaryInfo struct {
	File string // Path to binary file
	Name string // Binary file name
}

// ////////////////////////////////////////////////////////////////////////////////// //

// serviceDir is path to directory with system service files
var serviceDir = "/usr/lib/systemd/system"

// binaryDir is path to directory with binaries
var binaryDir = "/usr/bin"

// logDir is path to directory with logs
var logDir = "/var/log"

// configDir is path to directory with configuration files
var configDir = "/etc"

// unitComment is comment for service unit
var unitComment = "# Unit generated by ek.go/setup"

// checksum is current binary checksum
var checksum string

// ////////////////////////////////////////////////////////////////////////////////// //

// Install installs or reinstalls application on the system
func (app App) Install() error {
	bin := getBinaryInfo()
	err := checkForInstall(app, bin)

	if err != nil {
		return err
	}

	err = installFiles(app, bin)

	if err != nil {
		return err
	}

	exec.Command("systemctl", "daemon-reload").Run()

	return nil
}

// Uninstall uninstall unistalls application from the system
func (app App) Uninstall(full bool) error {
	bin := getBinaryInfo()
	err := checkForUninstall(app, bin)

	if err != nil {
		return err
	}

	err = uninstallFiles(app, bin, full)

	if err != nil {
		return err
	}

	exec.Command("systemctl", "daemon-reload").Run()

	return nil
}

// ////////////////////////////////////////////////////////////////////////////////// //

// BinPath returns binary installation path
func (b *binaryInfo) BinInstallPath() string {
	return path.Join(binaryDir, b.Name)
}

// LogDir returns logs directory path
func (b *binaryInfo) LogDir() string {
	return path.Join(logDir, b.Name)
}

// ServiceUnitPath returns service unit path
func (b *binaryInfo) ServiceUnitPath() string {
	return path.Join(serviceDir, b.Name+".service")
}

// IsBinInstalled returns true if current binary already installed
func (b *binaryInfo) IsBinInstalled() bool {
	return fsutil.IsExist(b.BinInstallPath()) &&
		b.Checksum() == hash.FileHash(b.BinInstallPath())
}

// IsServiceInstalled returns true if service unit already installed
func (b *binaryInfo) IsServiceInstalled() bool {
	return fsutil.IsExist(b.ServiceUnitPath())
}

// Checksum returns checksum of current binary
func (b *binaryInfo) Checksum() string {
	if checksum != "" {
		return checksum
	}

	checksum = hash.FileHash(b.File)

	return checksum
}

// ////////////////////////////////////////////////////////////////////////////////// //

// getBinary returns basic info about current binary
func getBinaryInfo() binaryInfo {
	bin, _ := os.Executable()
	binFile := path.Clean(bin)
	binName := path.Base(binFile)

	return binaryInfo{File: binFile, Name: binName}
}

// checkForInstall checks if app can be installed
func checkForInstall(app App, bin binaryInfo) error {
	if len(app.Configs) != 0 {
		for _, c := range app.Configs {
			if strings.Contains(c.Name, "/") {
				return fmt.Errorf("Configuration file name %q is invalid", c.Name)
			}
		}
	}

	user, err := system.CurrentUser()

	if err != nil {
		return fmt.Errorf("Can't get info about current user: %w", err)
	}

	if !user.IsRoot() {
		return fmt.Errorf("You must have superuser (root) privileges to install app as a service")
	}

	if bin.IsServiceInstalled() {
		isGenerated, err := isGeneratedUnit(bin.ServiceUnitPath())

		if err != nil {
			return fmt.Errorf("Can't check systemd unit: %w", err)
		}

		if !isGenerated {
			return fmt.Errorf("Can't replace systemd unit, it wasn't created by app")
		}
	}

	return nil
}

// checkForUninstall checks if app can be uninstalled
func checkForUninstall(app App, bin binaryInfo) error {
	if len(app.Configs) != 0 {
		for _, c := range app.Configs {
			if strings.Contains(c.Name, "/") {
				return fmt.Errorf("Configuration file name %q is invalid", c.Name)
			}
		}
	}

	if !bin.IsBinInstalled() {
		return fmt.Errorf("Binary is not installed (new binary?)")
	}

	if bin.File != bin.BinInstallPath() {
		return fmt.Errorf("You must use installed binary to uninstall service from the system")
	}

	user, err := system.CurrentUser()

	if err != nil {
		return fmt.Errorf("Can't get info about current user: %w", err)
	}

	if !user.IsRoot() {
		return fmt.Errorf("You must have superuser (root) privileges to uninstall this app")
	}

	if bin.IsServiceInstalled() {
		isGenerated, err := isGeneratedUnit(bin.ServiceUnitPath())

		if err != nil {
			return fmt.Errorf("Can't check systemd unit: %w", err)
		}

		if !isGenerated {
			return fmt.Errorf("Can't uninstall systemd unit, it wasn't created by app")
		}
	}

	return nil
}

// installFiles installs binary and systemd unit file
func installFiles(app App, bin binaryInfo) error {
	err := installConfigurationFiles(app)

	if err != nil {
		return err
	}

	if !bin.IsBinInstalled() {
		err := fsutil.CopyFile(bin.File, bin.BinInstallPath(), 0755)

		if err != nil {
			return fmt.Errorf("Can't copy binary to %s: %w", binaryDir, err)
		}
	}

	err = createServiceFile(app, bin)

	if err != nil {
		return fmt.Errorf("Can't install systemd service: %w", err)
	}

	if app.WithLog && !fsutil.IsExist(bin.LogDir()) {
		err := os.Mkdir(bin.LogDir(), 0755)

		if err != nil {
			return fmt.Errorf("Can't create directory for logs (%s): %w", bin.LogDir(), err)
		}
	}

	return nil
}

// uninstallFiles removes binary and systemd unit file
func uninstallFiles(app App, bin binaryInfo, full bool) error {
	if app.WithLog && full {
		os.RemoveAll(bin.LogDir())
	}

	err := os.Remove(bin.ServiceUnitPath())

	if err != nil {
		return fmt.Errorf("Can't remove systemd unit: %w", err)
	}

	err = os.Remove(bin.BinInstallPath())

	if err != nil {
		return fmt.Errorf("Can't remove binary: %w", err)
	}

	if full && len(app.Configs) > 0 {
		return uninstallConfigurationFiles(app)
	}

	return nil
}

// installConfigurationFiles creates all configuration files
func installConfigurationFiles(app App) error {
	if len(app.Configs) == 0 {
		return nil
	}

	for _, c := range app.Configs {
		filePath := path.Clean(path.Join(configDir, c.Name))

		// Don't rewrite files
		if len(c.Data) == 0 || fsutil.IsExist(filePath) {
			continue
		}

		fileMode := c.Mode

		if fileMode == 0 {
			fileMode = 0640
		}

		err := os.WriteFile(filePath, c.Data, fileMode)

		if err != nil {
			return fmt.Errorf("Can't create configuration file %q: %w", filePath, err)
		}
	}

	return nil
}

// uninstallConfigurationFiles removes all configuration files
func uninstallConfigurationFiles(app App) error {
	if len(app.Configs) == 0 {
		return nil
	}

	for _, c := range app.Configs {
		filePath := path.Clean(path.Join(configDir, c.Name))

		if !fsutil.IsExist(filePath) {
			continue
		}

		err := os.Remove(filePath)

		if err != nil {
			return fmt.Errorf("Can't delete configuration file %q: %w", filePath, err)
		}
	}

	return nil
}

// createServiceFile creates systemd service file
func createServiceFile(app App, bin binaryInfo) error {
	serviceUnitData := generateServiceUnit(app, bin)

	err := os.WriteFile(bin.ServiceUnitPath(), serviceUnitData, 0644)

	if err != nil {
		return fmt.Errorf("Can't create service file (%s): %w", bin.ServiceUnitPath(), err)
	}

	return nil
}

// generateServiceUnit generates systemd service file
func generateServiceUnit(app App, bin binaryInfo) []byte {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf(
		"%s (%s)\n\n",
		unitComment,
		strutil.Head(bin.Checksum(), 7),
	))

	buf.WriteString("[Unit]\n")
	buf.WriteString(fmt.Sprintf("Description=%s\n", strutil.Q(app.Name, bin.Name)))

	if app.DocsURL != "" {
		buf.WriteString(fmt.Sprintf("Documentation=%s\n", app.DocsURL))
	}

	buf.WriteString("After=network-online.target remote-fs.target nss-lookup.target\n")
	buf.WriteString("Wants=network-online.target\n\n")
	buf.WriteString("[Service]\n")
	buf.WriteString("Type=simple\n")

	if app.User != "" {
		buf.WriteString(fmt.Sprintf("User=%s\n", app.User))
	}

	if len(app.Options) > 0 {
		buf.WriteString(fmt.Sprintf(
			"ExecStart=%s %s\n", path.Join(binaryDir, bin.Name), strings.Join(app.Options, " "),
		))
	} else {
		buf.WriteString(fmt.Sprintf("ExecStart=%s\n", path.Join(binaryDir, bin.Name)))
	}

	if app.ReloadSignal != "" {
		buf.WriteString(fmt.Sprintf(
			"ExecReload=/bin/kill -s %s $MAINPID\n", app.ReloadSignal,
		))
	}

	if app.StopSignal != "" {
		buf.WriteString(fmt.Sprintf(
			"ExecStop=/bin/kill -s %s $MAINPID\n", app.StopSignal,
		))
	}

	if app.WithLog {
		buf.WriteString(fmt.Sprintf(
			"StandardError=file:%s/startup.log\n", bin.LogDir(),
		))
	}

	if !app.WithoutPrivateTemp {
		buf.WriteString("PrivateTmp=true\n")
	}

	buf.WriteString("\n[Install]\nWantedBy=multi-user.target\n\n")

	return buf.Bytes()
}

// isGeneratedUnit returns true if given systemd unit generated by this package
func isGeneratedUnit(file string) (bool, error) {
	unitData, err := os.ReadFile(file)

	if err != nil {
		return false, err
	}

	return bytes.HasPrefix(unitData, []byte(unitComment)), nil
}
