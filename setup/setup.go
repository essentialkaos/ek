//go:build linux
// +build linux

// Package setup provides methods to install/unistall application as a service on the
// system
package setup

// ////////////////////////////////////////////////////////////////////////////////// //
//                                                                                    //
//                         Copyright (c) 2024 ESSENTIAL KAOS                          //
//      Apache License, Version 2.0 <https://www.apache.org/licenses/LICENSE-2.0>     //
//                                                                                    //
// ////////////////////////////////////////////////////////////////////////////////// //

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"strings"

	"github.com/essentialkaos/ek/v13/fsutil"
	"github.com/essentialkaos/ek/v13/hash"
	"github.com/essentialkaos/ek/v13/path"
	"github.com/essentialkaos/ek/v13/strutil"
	"github.com/essentialkaos/ek/v13/system"
)

// ////////////////////////////////////////////////////////////////////////////////// //

// App contains basic application configuration
type App struct {
	Name       string   // Application name
	Options    []string // List of options
	DocsURL    string   // Documentation URL
	User       string   // Service user
	Identifier string   // Syslog identifier
	WorkingDir string   // Working dir

	StopSignal   string // Stop signal
	ReloadSignal string // Reload signal

	WithLog            bool // Create directory for logs
	WithoutPrivateTemp bool // Disable private temp
}

// ////////////////////////////////////////////////////////////////////////////////// //

// binaryInfo contains basic info about binary
type binaryInfo struct {
	File string // Path to binary file
	Name string // Binary file name
}

// ////////////////////////////////////////////////////////////////////////////////// //

// serviceDir is path to directory with system service files
var serviceDir = "/usr/lib/systemd/system"

// binaryDir is path to directory with binaries
var binaryDir = "/usr/bin"

// logDir is path to directory with logs
var logDir = "/var/log"

// unitComment is comment for service unit
var unitComment = "# Unit generated by ek.go/setup"

// ////////////////////////////////////////////////////////////////////////////////// //

// Install installs or reinstalls application on the system
func (app App) Install() error {
	bin := getBinaryInfo()
	err := bin.checkForInstall()

	if err != nil {
		return err
	}

	err = installFiles(app, bin)

	if err != nil {
		return err
	}

	exec.Command("systemctl", "daemon-reload").Run()

	return nil
}

// Uninstall uninstall unistalls application from the system
func (app App) Uninstall(full bool) error {
	bin := getBinaryInfo()
	err := bin.checkForUninstall()

	if err != nil {
		return err
	}

	err = uninstallFiles(app, bin, full)

	if err != nil {
		return err
	}

	exec.Command("systemctl", "daemon-reload").Run()

	return nil
}

// ////////////////////////////////////////////////////////////////////////////////// //

// BinPath returns binary installation path
func (b *binaryInfo) BinInstallPath() string {
	return path.Join(binaryDir, b.Name)
}

// LogDir returns logs directory path
func (b *binaryInfo) LogDir() string {
	return path.Join(logDir, b.Name)
}

// ServiceUnitPath returns service unit path
func (b *binaryInfo) ServiceUnitPath() string {
	return path.Join(serviceDir, b.Name+".service")
}

// IsBinInstalled returns true if current binary already installed
func (b *binaryInfo) IsBinInstalled() bool {
	return fsutil.IsExist(b.BinInstallPath()) &&
		hash.FileHash(b.File) == hash.FileHash(b.BinInstallPath())
}

// IsServiceInstalled returns true if service unit already installed
func (b *binaryInfo) IsServiceInstalled() bool {
	return fsutil.IsExist(b.ServiceUnitPath())
}

// checkForInstall checks if current binary can be installed
func (b *binaryInfo) checkForInstall() error {
	user, err := system.CurrentUser()

	if err != nil {
		return fmt.Errorf("Can't get info about current user: %w", err)
	}

	if !user.IsRoot() {
		return fmt.Errorf("You must have superuser (root) privileges to install app as a service")
	}

	if b.IsServiceInstalled() {
		isGenerated, err := isGeneratedUnit(b.ServiceUnitPath())

		if err != nil {
			return fmt.Errorf("Can't check systemd unit: %w", err)
		}

		if !isGenerated {
			return fmt.Errorf("Can't replace systemd unit, it wasn't created by app")
		}
	}

	return nil
}

// checkForUninstall checks if current binary can be uninstalled
func (b *binaryInfo) checkForUninstall() error {
	if b.IsBinInstalled() {
		return fmt.Errorf("Binary is not installed")
	}

	if b.File != b.BinInstallPath() {
		return fmt.Errorf("You must use installed binary to uninstall service from the system")
	}

	user, err := system.CurrentUser()

	if err != nil {
		return fmt.Errorf("Can't get info about current user: %w", err)
	}

	if !user.IsRoot() {
		return fmt.Errorf("You must have superuser (root) privileges to uninstall this app")
	}

	if b.IsServiceInstalled() {
		isGenerated, err := isGeneratedUnit(b.ServiceUnitPath())

		if err != nil {
			return fmt.Errorf("Can't check systemd unit: %w", err)
		}

		if !isGenerated {
			return fmt.Errorf("Can't uninstall systemd unit, it wasn't created by app")
		}
	}

	return nil
}

// ////////////////////////////////////////////////////////////////////////////////// //

// getBinary returns basic info about current binary
func getBinaryInfo() binaryInfo {
	binFile := path.Clean(os.Args[0])
	binName := path.Base(binFile)

	return binaryInfo{File: binFile, Name: binName}
}

// installFiles installs binary and systemd unit file
func installFiles(app App, bin binaryInfo) error {
	if !bin.IsBinInstalled() {
		err := fsutil.CopyFile(bin.File, bin.BinInstallPath(), 0755)

		if err != nil {
			return fmt.Errorf("Can't copy binary to %s: %w", binaryDir, err)
		}
	}

	err := createServiceFile(app, bin)

	if err != nil {
		return fmt.Errorf("Can't install systemd service: %w", err)
	}

	if app.WithLog && !fsutil.IsExist(bin.LogDir()) {
		err := os.Mkdir(bin.LogDir(), 0755)

		if err != nil {
			return fmt.Errorf("Can't create directory for logs (%s): %w", bin.LogDir(), err)
		}
	}

	return nil
}

// uninstallFiles removes binary and systemd unit file
func uninstallFiles(app App, bin binaryInfo, full bool) error {
	if app.WithLog && full {
		os.RemoveAll(bin.LogDir())
	}

	err := os.Remove(bin.ServiceUnitPath())

	if err != nil {
		return fmt.Errorf("Can't remove systemd unit: %w", err)
	}

	err = os.Remove(bin.BinInstallPath())

	if err != nil {
		return fmt.Errorf("Can't remove binary: %w", err)
	}

	return nil
}

// createServiceFile creates systemd service file
func createServiceFile(app App, bin binaryInfo) error {
	serviceUnitData := generateServiceUnit(app, bin)

	err := os.WriteFile(bin.ServiceUnitPath(), serviceUnitData, 0644)

	if err != nil {
		return fmt.Errorf("Can't create service file (%s): %w", bin.ServiceUnitPath(), err)
	}

	return nil
}

// generateServiceUnit generates systemd service file
func generateServiceUnit(app App, bin binaryInfo) []byte {
	var buf bytes.Buffer

	buf.WriteString(unitComment + "\n\n")
	buf.WriteString("[Unit]\n")
	buf.WriteString(fmt.Sprintf("Description=%s\n", strutil.Q(app.Name, bin.Name)))

	if app.DocsURL != "" {
		buf.WriteString(fmt.Sprintf("Documentation=%s\n", app.DocsURL))
	}

	buf.WriteString("After=network-online.target remote-fs.target nss-lookup.target\n")
	buf.WriteString("Wants=network-online.target\n\n")
	buf.WriteString("[Service]\n")
	buf.WriteString("Type=simple\n")

	if app.User != "" {
		buf.WriteString(fmt.Sprintf("User=%s\n", app.User))
	}

	if len(app.Options) > 0 {
		buf.WriteString(fmt.Sprintf(
			"ExecStart=%s %s\n", bin.Name, strings.Join(app.Options, " "),
		))
	} else {
		buf.WriteString(fmt.Sprintf("ExecStart=%s\n", bin.Name))
	}

	if app.ReloadSignal != "" {
		buf.WriteString(fmt.Sprintf(
			"ExecReload=/bin/kill -s %s $MAINPID\n", app.ReloadSignal,
		))
	}

	if app.StopSignal != "" {
		buf.WriteString(fmt.Sprintf(
			"ExecStop=/bin/kill -s %s $MAINPID\n", app.StopSignal,
		))
	}

	if app.WithLog {
		buf.WriteString(fmt.Sprintf(
			"StandardError=file:%s/startup.log\n", bin.LogDir(),
		))
	}

	if !app.WithoutPrivateTemp {
		buf.WriteString("PrivateTmp=true\n")
	}

	buf.WriteString("\n[Install]\nWantedBy=multi-user.target\n\n")

	return buf.Bytes()
}

// isGeneratedUnit returns true if given systemd unit generated by this package
func isGeneratedUnit(file string) (bool, error) {
	unitData, err := os.ReadFile(file)

	if err != nil {
		return false, err
	}

	return bytes.HasPrefix(unitData, []byte(unitComment)), nil
}
